package rpc_service

import (
	"errors"
	proto "github.com/golang/protobuf/proto"
	logger "github.com/ipfs/go-log"
	"gitlab.com/go-msuite/app-errors"
	helper "gitlab.com/go-msuite/common/go-common"
	msgs "gitlab.com/go-msuite/common/pb"
	"gitlab.com/go-msuite/configurator/config_service/grpc_server"
	"gitlab.com/go-msuite/locker"
	"gitlab.com/go-msuite/store"
	storeItem "gitlab.com/go-msuite/store/item"
	Batch "gitlab.com/trainer/batch/pb"
	Inventory "gitlab.com/trainer/inventory/pb"
	"golang.org/x/net/context"
	"sync/atomic"
)

var log = logger.Logger("inventory")

var (
	req_id int64 = 1
)

func getNextId() int64 {
	return atomic.AddInt64(&req_id, 1)
}

type inventoryItem struct {
	*Inventory.Item
}

// GetId is generated by grpc
func (l *inventoryItem) GetNamespace() string { return "inventory" }

func (l *inventoryItem) SetCreated(i int64) { l.Created = i }

func (l *inventoryItem) SetUpdated(i int64) { l.Updated = i }

type inventory struct {
	baseSrv grpc_server.BaseGrpcService
	dbP     store.Store
	lckr    locker.Locker
}

var InitFn grpc_server.RPCInitFn = Init

var DB = "redis"
var LOCKER = "zookeeper"

func Init(base grpc_server.BaseGrpcService) error {

	if base.GetDb(DB) == nil || base.GetLocker(LOCKER) == nil {
		return errors.New("Incomplete config for inventory")
	}
	i := &inventory{
		baseSrv: base,
		dbP:     base.GetDb(DB),
		lckr:    base.GetLocker(LOCKER),
	}
	base.RegisterEvent("updateBatch", func() proto.Message {
		return &Batch.UpdateReq{}
	}, i.handleUpdateBatch)
	Inventory.RegisterInventoryServer(base.GetRPCServer(), i)
	return nil
}

func (s *inventory) Get(c context.Context, ids *msgs.UUIDs) (retItems *Inventory.Items, retErr error) {

	items := make([]storeItem.Item, len(ids.Vals))

	err := helper.ParallelGetHelper(c, ids, func(id string) storeItem.Item {
		return &inventoryItem{&Inventory.Item{Id: id}}
	}, items, s.lckr, s.dbP)
	if err != nil {
		log.Errorf("ParallelGetHelper failed Err:%s", err.Error())
		retErr = app_errors.ErrInternal("Failed listing Inventory items")
		return
	}

	retItems = new(Inventory.Items)
	retItems.Items = make([]*Inventory.Item, len(items))
	for i, v := range items {
		retItems.Items[i] = v.(*inventoryItem).Item
	}
	return
}

func (s *inventory) Update(c context.Context, item *Inventory.UpdateReq) (retItem *Inventory.Item, retErr error) {

	inv := &inventoryItem{
		Item: item.Item,
	}

	unlock, err := s.lckr.TryLock(inv, locker.DefaultTimeout)
	if err != nil {
		log.Errorf("Failed getting lock Err:%s", err.Error())
		retErr = app_errors.ErrInternal("Failed to get inventory lock.")
		return
	}
	defer unlock()

	if item.Map == int32(Inventory.UpdateReq_NEW) {
		retErr = s.dbP.Create(inv)
	} else {
		retErr = s.dbP.Update(inv)
	}

	if retErr != nil {
		log.Errorf("Failed updating inventory item Err:%s", retErr.Error())
		retErr = app_errors.ErrInternal("Failed to update inventory item.")
		return
	}
	retItem = inv.Item
	return
}

func (s *inventory) List(c context.Context, req *msgs.ListReq) (retItems *Inventory.Items, retErr error) {

	items := make([]storeItem.Item, req.Limit)

	for i := range items {
		items[i] = &inventoryItem{
			Item: new(Inventory.Item),
		}
	}

	listOpt := storeItem.ListOpt{
		Page:  req.Page,
		Limit: req.Limit,
	}

	count, err := s.dbP.List(items, listOpt)
	if err != nil {
		log.Errorf("Failed listing inventory items Err:%s", err.Error())
		retErr = app_errors.ErrInternal("Failed to list inventory items.")
		return
	}

	retItems = new(Inventory.Items)
	retItems.Items = make([]*Inventory.Item, count)
	for i := 0; i < count; i++ {
		retItems.Items[i] = items[i].(*inventoryItem).Item
	}
	return
}

func (s *inventory) handleUpdateBatch(msg proto.Message) error {
	updBatch, ok := msg.(*Batch.UpdateReq)
	if !ok {
		log.Errorf("Invalid msg object for batch update event")
		return errors.New("Incompatible message")
	}
	// Community service only cares about addition/deletion of batches
	if updBatch.Map == int32(Batch.UpdateReq_NEW) {
		inv := &inventoryItem{
			Item: &Inventory.Item{
				Id:     updBatch.Item.Id,
				Rates:  updBatch.Item.Rates,
				Active: updBatch.Item.Active,
				Count:  updBatch.Item.Slots,
			},
		}
		err := s.dbP.Update(inv)
		if err != nil {
			log.Errorf("Failed update inventory %s Err:%s", inv.GetId(), err.Error())
			return err
		}
		log.Infof("Added new inventory item corresponding to batch %s", updBatch.Item.Id)
	} else if updBatch.Map&int32(Batch.UpdateReq_ACTIVE) > 0 {
		inv := &inventoryItem{Item: &Inventory.Item{Id: updBatch.Item.Id}}
		unlock, err := s.lckr.TryLock(inv, locker.DefaultTimeout)
		if err != nil {
			log.Errorf("Failed getting lock on %s", inv.GetId())
			return err
		}
		defer unlock()
		err = s.dbP.Read(inv)
		if err != nil {
			log.Errorf("Failed to read inventory item %s Err:%s", inv.GetId(), err.Error())
			return err
		}
		if inv.Active != updBatch.Item.Active {
			inv.Active = updBatch.Item.Active
			err := s.dbP.Update(inv)
			if err != nil {
				log.Errorf("Failed updating inventory item %s, Err:%s", inv.GetId(),
					err.Error())
				return err
			}
			log.Infof("Updated inventory item %s Active to %b", inv.GetId(),
				updBatch.Item.Active)
		}
	}
	return nil
}
